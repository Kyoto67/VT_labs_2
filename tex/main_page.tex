\section{1067. Структура папок}
\textit{Условие задачи:} \par
Хакер Билл случайно потерял всю информацию с жесткого диска своего компьютера, и у него нет резервных копий его
содержимого. Но он сожалеет не о потере самих файлов, а о потере очень понятной и удобной структуры папок, которую
он создавал и сохранял в течение многих лет работы. К счастью, у Билла есть несколько копий списков папок с его
жесткого диска. С помощью этих списков он смог восстановить полные пути к некоторым папкам (например,
«WINNT\textbackslash SYSTEM32\textbackslash CERTSRV\textbackslash CERTCO~1\textbackslash X86»).
Он поместил их все в файл, записав каждый найденный путь в отдельную строку. Напишите программу, которая восстановит
структуру папок Билла и выведет ее в виде отформатированного дерева.

\textit{Пояснение к примененному алгоритму:} \par
Читаем и сохраняем все строки. Сортируем строки лексикографически в иерархическом порядке. Проходим по всем строкам,
сравнивая их с предыдущими - если у них общий "корень", то стираем его и выводим оставшуюся часть строки с нужным отступом.


\underline{Сложность алгоритма:} O(N)  чтение + O(Nlog(N)M) сортировка строк + O(N*M) сравнение и вывод строк $\approx$
O(MNlog(N)), где M - длина наибольшей строки ( $\leq$ 80)

\textit{Код:}
\small
\begin{center}
    \begin{verbatim}
    static const char DELIM = 92;

size_t comp_paths(const std::string prev, const std::string curr, size_t *count_delims) {
    size_t saved_len = 0;
    size_t curr_len = 0;
    if (prev.length() == 0) return saved_len;
    for (size_t i = 0; i < prev.length(); i++) {
        if (prev[i] != curr[i]) {
            if (i != prev.length() && (*count_delims) != 0) (*count_delims)--;
            return saved_len;
        }
        if (curr[i] == DELIM) {
            (*count_delims)++;
            saved_len = curr_len;
        }
        curr_len++;
    }
    if (curr[prev.length()] == DELIM) return curr_len;
    (*count_delims)--;
    return saved_len;
}

bool comp(std::string s1, std::string s2) {
    for (size_t i = 0; i < std::min(s1.length(), s2.length()); i++) {
        if (s1[i] == DELIM && s2[i] != DELIM) return true;
        if (s2[i] == DELIM && s1[i] != DELIM) return false;
        if (s2[i] < s1[i]) return false;
        if (s1[i] < s2[i]) return true;
    }
    if (s1.length() < s2.length()) return true;
    else return false;
}

int main() {
    size_t N;
    std::cin >> N;
    std::vector<std::string> set;
    for (size_t i = 0; i < N; i++) {
        std::string line;
        std::cin >> line;
        set.push_back(line);
    }
    std::sort(set.begin(), set.end(), comp);
    std::string last_line;
    for (std::string s: set) {
        size_t count_delims = 0;
        size_t len_to_trim = comp_paths(last_line, s, &count_delims);
        if (len_to_trim == s.length()) {
            continue;
        }
        last_line = s;
        s = s.substr(len_to_trim);
        for (int i = 0; i < s.length(); i++) {
            if (s[i] == DELIM) {
                count_delims++;
                for (int j = 0; j < count_delims; j++) {
                    std::cout << " ";
                }
            } else {
                std::cout << s[i];
                if (s[i + 1] == DELIM) std::cout << std::endl;
            }
        }
        std::cout << std::endl;
    }
    return 0;
}
    \end{verbatim}
\end{center}
\normalsize
\newpage

\section{1628. Белые полосы}
\textit{Условие задачи:} \par
У каждого неудачника в жизни бывают не только чёрные, но и белые полосы. Марсианин Вась-Вась отмечает в календаре,
представляющем собой таблицу m × n, те дни, когда ему ужасно не повезло. Если Вась-Васю не повезло в j-й день i-й недели,
то он закрашивает ячейку таблицы (i, j) в чёрный цвет. Все незакрашенные ячейки в таблице имеют белый цвет. Будем называть
отрезками жизни прямоугольники размером 1 × l либо l × 1. Белыми полосами Вась-Вась считает все максимальные по
включению белые отрезки таблицы. А сможете ли Вы определить, сколько всего белых полос было в жизни Вась-Вася?
\textit{Пояснение к примененному алгоритму:} \par
Читаем координаты занятых ячеек и записываем их в вектор в виде пары координат {x,y}, так же добавляем в вектор ячейки,
формирующие границы календаря. Сортируем вектор так, чтобы ячейки шли по порядку своего расположения в строках (слева-направо, сверху-вниз).
Проходим по порядку вектор, считая все свободные "стрики" длиной > 1, и сохраняя в unordered set все одиночные свободные дни.
Далее сортируем вектор по порядку расположения в столбцах (сверху-вниз, слева-направо). Опять проходим по нему, считая
все свободные "стрики" длиной > 1, а, встречая одиночный свободный день, проверяем, был ли он одиночным при прошлом проходе,
если да - это изолированный свободный день, и его считаем как "стрик" длиной 1.


\underline{Сложность алгоритма:} O(X) чтение + O(XlogX) сортировка + O(X) проход по вектору $\approx$ O(XlogX), где X=N+M+K.


\textit{Код:}
\small
\begin{center}
    \begin{verbatim}
static size_t m, n, k;

bool sort_for_horizontal(std::pair<int64_t, int64_t> p1, std::pair<int64_t, int64_t> p2) {
    if (p1.first < p2.first) return true;
    else if (p1.first == p2.first) return p1.second < p2.second;
    else return false;
}

bool sort_for_vertical(std::pair<int64_t, int64_t> p1, std::pair<int64_t, int64_t> p2) {
    if (p1.second < p2.second) return true;
    else if (p2.second == p1.second) return p1.first < p2.first;
    else return false;
}

int main() {
    std::cin >> m >> n >> k;
    std::vector<std::pair<int64_t, int64_t>> busy_cells;
    for (size_t i = 0; i < m + 2; i++) {
        busy_cells.push_back({i, 0});
        busy_cells.push_back({i, n + 1});
    }
    for (size_t i = 1; i < n + 1; i++) {
        busy_cells.push_back({0, i});
        busy_cells.push_back({m + 1, i});
    }
    for (size_t i = 0; i < k; i++) {
        size_t x;
        size_t y;
        std::cin >> x >> y;
        busy_cells.push_back({(x), (y)});
    }

    std::unordered_set<uint32_t> one_days;
    size_t count_stripes = 0;

    std::sort(busy_cells.begin(), busy_cells.end(), sort_for_horizontal);
    for (size_t i = 1; i < busy_cells.size(); i++) {
        std::pair<int64_t, int64_t> prev = busy_cells[i - 1];
        std::pair<int64_t, int64_t> curr = busy_cells[i];

        if (curr.first == prev.first) {

            int64_t dist = curr.second - prev.second - 1;
            if (dist == 1) {
                one_days.emplace(curr.first * n + curr.second - 1);
            } else if (dist > 1) {
                count_stripes++;
            }
        }

    }

    std::sort(busy_cells.begin(), busy_cells.end(), sort_for_vertical);

    for (size_t i = 1; i < busy_cells.size(); i++) {
        std::pair<int64_t, int64_t> prev = busy_cells[i - 1];
        std::pair<int64_t, int64_t> curr = busy_cells[i];

        if (curr.second == prev.second) {

            int64_t dist = curr.first - prev.first - 1;
            if (dist == 1) {
                auto item = one_days.find((curr.first - 1) * n + curr.second);
                if (item != one_days.end()) {
                    count_stripes++;
                }
            } else if (dist > 1) {
                count_stripes++;
            }
        }

    }
    std::cout << count_stripes;
    return 0;
}
    \end{verbatim}
\end{center}